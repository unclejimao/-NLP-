# regular expression 正则表达式

>正则表达式是一个特殊的字符序列，它能帮助你方便的检查一个字符串是否与某种模式匹配。
>
>Python 自1.5版本起增加了re 模块，它提供 Perl 风格的正则表达式模式。
>
>re 模块使 Python 语言拥有全部的正则表达式功能。
>
>compile 函数根据一个模式字符串和可选的标志参数生成一个正则表达式对象。该对象拥有一系列方法用于正则表达式匹配和替换。
>
>re 模块也提供了与这些方法功能完全一致的函数，这些函数使用一个模式字符串做为它们的第一个参数。

详细使用方法参考 http://www.runoob.com/python/python-reg-expressions.html

## 正则表达式模式

>模式字符串使用特殊的语法来表示一个正则表达式：
>
>字母和数字表示他们自身。一个正则表达式模式中的字母和数字匹配同样的字符串。
>
>多数字母和数字前加一个反斜杠时会拥有不同的含义。
>
>标点符号只有被转义时才匹配自身，否则它们表示特殊的含义。
>
>反斜杠本身需要使用反斜杠转义。
>
>由于正则表达式通常都包含反斜杠，所以你最好使用原始字符串来表示它们。模式元素(如 r'\t'，等价于 '\\t')匹配相应的特殊字符。
>
>下表列出了正则表达式模式语法中的特殊元素。如果你使用模式的同时提供了可选的标志参数，某些模式元素的含义会改变。

|模式 |描述|
|:------|:------|
|^|	匹配字符串的开头|
|$|	匹配字符串的末尾。|
|.|	匹配任意字符，除了换行符，当re.DOTALL标记被指定时，则可以匹配包括换行符的任意字符。|
|[...]	|用来表示一组字符,单独列出：[amk] 匹配 'a'，'m'或'k'|
|[^...]	|不在[]中的字符：[^abc] 匹配除了a,b,c之外的字符。|
|re*	|匹配0个或多个的表达式。|
|re+	|匹配1个或多个的表达式。|
|re?	|匹配0个或1个由前面的正则表达式定义的片段，非贪婪方式|
|re{ n}	|精确匹配 n 个前面表达式。例如， o{2} 不能匹配 "Bob" 中的 "o"，但是能匹配 "food" 中的两个 o。|
|re{ n,}	|匹配 n 个前面表达式。例如， o{2,} 不能匹配"Bob"中的"o"，但能匹配 "foooood"中的所有 o。"o{1,}" 等价于 "o+"。"o{0,}" 则等价于 "o*"。|
|re{ n, m}	|匹配 n 到 m 次由前面的正则表达式定义的片段，贪婪方式|
|a| b	|匹配a或b|
|(re)	|匹配括号内的表达式，也表示一个组|
|(?imx)	|正则表达式包含三种可选标志：i, m, 或 x 。只影响括号中的区域。|
|(?-imx)	|正则表达式关闭 i, m, 或 x 可选标志。只影响括号中的区域。|
|(?: re)	|类似 (...), 但是不表示一个组|
|(?imx: re)	|在括号中使用i, m, 或 x 可选标志|
|(?-imx: re)	|在括号中不使用i, m, 或 x 可选标志|
|(?#...)	|注释.|
|(?= re)	|前向肯定界定符。如果所含正则表达式，以 ... 表示，在当前位置成功匹配时成功，否则失败。但一旦所含表达式已经尝试，匹配引擎根本没有提高；模式的剩余部分还要尝试界定符的右边。|
|(?! re)	|前向否定界定符。与肯定界定符相反；当所含表达式不能在字符串当前位置匹配时成功|
|(?> re)	|匹配的独立模式，省去回溯。|
|\w	|匹配字母数字及下划线|
|\W	|匹配非字母数字及下划线|
|\s	|匹配任意空白字符，等价于 [\t\n\r\f].|
|\S	|匹配任意非空字符|
|\d	|匹配任意数字，等价于 [0-9].|
|\D	|匹配任意非数字|
|\A	|匹配字符串开始|
|\Z	|匹配字符串结束，如果是存在换行，只匹配到换行前的结束字符串。|
|\z	|匹配字符串结束|
|\G	|匹配最后匹配完成的位置。|
|\b	|匹配一个单词边界，也就是指单词和空格间的位置。例如， 'er\b' 可以匹配"never" 中的 'er'，但不能匹配 "verb" 中的 'er'。|
|\B	|匹配非单词边界。'er\B' 能匹配 "verb" 中的 'er'，但不能匹配 "never" 中的 'er'。|
|\n, \t, 等.|	匹配一个换行符。匹配一个制表符。等|
|\1...\9	|匹配第n个分组的内容。|
|\10	|匹配第n个分组的内容，如果它经匹配。否则指的是八进制字符码的表达式。|

## 正则表达式实例

### 字符匹配

|实例|描述|
|------|------|
|python	|匹配 "python".|

### 字符类
|实例|描述|
|------|------|
|[Pp]ython| 	匹配 "Python" 或 "python"|
|rub[ye]	|匹配 "ruby" 或 "rube"|
|[aeiou]	|匹配中括号内的任意一个字母|
|[0-9]	|匹配任何数字。类似于 [0123456789]|
|[a-z]	|匹配任何小写字母|
|[A-Z]	|匹配任何大写字母|
|[a-zA-Z0-9]	|匹配任何字母及数字|
|[^aeiou]	|除了aeiou字母以外的所有字符|
|[^0-9]	|匹配除了数字外的字符 |

### 特殊字符类
|实例|描述|
|------|------|
|.	|匹配除 "\n" 之外的任何单个字符。要匹配包括 '\n' 在内的任何字符，请使用象 '[.\n]' 的模式。|
|\d	|匹配一个数字字符。等价于 [0-9]。|
|\D |匹配一个非数字字符。等价于 [^0-9]。|
|\s	|匹配任何空白字符，包括空格、制表符、换页符等等。等价于 [ \f\n\r\t\v]。|
|\S |匹配任何非空白字符。等价于 [^ \f\n\r\t\v]。|
|\w	|匹配包括下划线的任何单词字符。等价于'[A-Za-z0-9_]'。|
|\W	|匹配任何非单词字符。等价于 '[^A-Za-z0-9_]'。|

## cut_data.py中的正则匹配语句解释

     regex1 = u'(?:[^\u4e00-\u9fa5（）*&……%￥$，,。.@! ！]){1,5}期'  # 非汉字xxx期
     regex2 = r'(?:[0-9]{1,3}[.]?[0-9]{1,3})%'  # xx.xx%

前面的一个 r 表示字符串为非转义的原始字符串，让编译器忽略反斜杠，也就是忽略转义字符。

以u或U开头的字符串表示unicode字符串,因为字符串中含有中文，以u开头防止报错。

u不是针对中文, 可以针对任何的字符串。
它代表是对字符串进行unicode编码。
一般英文字符在使用各种编码下, 基本都可以正常解析, 所以一般也就不带u了。
但是中文, 必须表明所需编码, 否则一旦编码转换就会出现乱码。

建议所有编码方式采用utf8 

“？：” 非获取匹配，匹配冒号后的内容但不获取匹配结果，不进行存储供以后使用,可以用来提高执行速度。

单独的“？” 匹配前面的子表达式零次或一次。

当“？”紧跟在任何一个其他限制符（*,+,?，{n}，{n,}，{n,m}）后面时，匹配模式是非贪婪的。非贪婪模式尽可能少地匹配所搜索的字符串，而默认的贪婪模式则尽可能多地匹配所搜索的字符串。

 [u4e00-u9fa5] ：匹配中文字符所有Unicode编码的正则表达式
 
 [^\u4e00-\u9fa5（）*&……%￥$，,。.@! ！]：匹配非汉字、非所列特殊字符的正则表达式
 
只要是”^”这个字符是在中括号”[]”中被使用的话就是表示字符类的否定，如果不是的话就是表示限定开头。这里说的是直接在”[]”中使用，不包括嵌套使用。

其实也就是说”[]”代表的是一个字符集，”^”只有在字符集中才是反向字符集的意思。
 
### 基础语法
 "^([]{})([]{})([]{})$"

正则字符串 = "开始（[包含内容]{长度}）（[包含内容]{长度}）（[包含内容]{长度}）结束" 

### 实例
　　字符串；tel:086-0666-88810009999

　　原始正则："^tel:[0-9]{1,3}-[0][0-9]{2,3}-[0-9]{8,11}$"

　　速记理解：开始 "tel:普通文本"[0-9数字]{1至3位}"-普通文本"[0数字][0-9数字]{2至3位}"-普通文本"[0-9数字]{8至11位} 结束"

### 编译

    p1 = re.compile(regex1)
    p2 = re.compile(regex2)

当我们在Python中使用正则表达式时，re模块内部会干两件事情：

    1. 编译正则表达式，如果正则表达式的字符串本身不合法，会报错；

    2. 用编译后的正则表达式去匹配字符串。

如果一个正则表达式要重复使用几千次，出于效率的考虑，我们可以预编译该正则表达式

#### re.compile 函数

compile 函数用于编译正则表达式，生成一个正则表达式（ Pattern ）对象，供 match() 和 search() 这两个函数使用。

语法格式为：

     re.compile(pattern[, flags])

参数：

    pattern : 一个字符串形式的正则表达式

    flags : 可选，表示匹配模式，比如忽略大小写，多行模式等，具体参数为：
        re.I 忽略大小写
        re.L 表示特殊字符集 \w, \W, \b, \B, \s, \S 依赖于当前环境
        re.M 多行模式
        re.S 即为 . 并且包括换行符在内的任意字符（. 不包括换行符）
        re.U 表示特殊字符集 \w, \W, \b, \B, \d, \D, \s, \S 依赖于 Unicode 字符属性数据库
        re.X 为了增加可读性，忽略空格和 # 后面的注释

#### re.sub 函数
      
Python 的 re 模块提供了re.sub用于替换字符串中的匹配项。

语法：

     re.sub(pattern, repl, string, count=0, flags=0)

参数：

    pattern : 正则中的模式字符串。
    repl : 替换的字符串，也可为一个函数。
    string : 要被查找替换的原始字符串。
    count : 模式匹配后替换的最大次数，默认 0 表示替换所有的匹配。
    
#### re.findall 函数

在字符串中找到正则表达式所匹配的所有子串，并返回一个**列表**，如果没有找到匹配的，则返回空列表。

语法格式为：

    findall(string[, pos[, endpos]])

参数：

    string : 待匹配的字符串。
    pos : 可选参数，指定字符串的起始位置，默认为 0。
    endpos : 可选参数，指定字符串的结束位置，默认为字符串的长度。